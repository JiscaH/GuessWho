% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Offspring.R
\name{FilterCand}
\alias{FilterCand}
\title{Find best-matching field parent for each pedigree sibship}
\usage{
FilterCand(
  CPM = NULL,
  CandPar.OK = NULL,
  NonUnique = c("INVIS", "NONE", "REF"),
  LL.th = c(seq(10, 2, -1), seq(1, 0.5, -0.1)),
  verbose = TRUE
)
}
\arguments{
\item{CPM}{matrix with with log10-probabilities that field parent j (columns)
is the parent of all individuals in sibship i (rows) (Log-Parent-of-All).}

\item{CandPar.OK}{dataframe with id's matched in the previous iteration of
\code{\link{MatchIDsPedigreeField}}, with at least columns id - Cand.id -
L.off.}

\item{NonUnique}{vector with column names that do not represent a unique
field parent and thus may be matched to multiple pedigree sibhips, e.g.
'INVIS'.}

\item{LL.th}{numeric vector with assignment thresholds for each iteration, on
log10 scale.}

\item{verbose}{print the update step and new log-likelihood to the console
each iteration.}
}
\value{
a matrix (\code{M.allow}) with the same dimensions as CPM. In case of
  a conclusive match between pedigree parent 'i' and field parent
  'j', M.allow[i,j]=1 (allowed), M.allow[i,-j]=NA (disallowed) and
  M.allow[-i,j]=NA. In absence of a conclusive match, M.allow[i,]=1, except
  for those j's where already a conclusive match is made, and vice versa for
  M.allow[,j]. Coding as 'NA' instead of '0' enables operations like
  \code{which.max(CPM[i,] * M.allow[i,])} and the like.
}
\description{
Match each sibship cluster, sharing the same (dummy or
  genotyped) pedigree parent, to a candidate field parent or INVIS, ensuring
  that each field parent is matched to at most one pedigree sibship.
}
\examples{
\dontrun{
if (r>1) {
  CandPar.OK <- cand.ok[[r-1]]  # confirmed and/or name replaced at end prev. iteration
} else {
  CandPar.OK <- NULL
}
M.allow <- FilterCand(CPM = candpar.M,
                      CandPar.OK = CandPar.OK,
                      NonUnique = c("INVIS", "REF"),   #, "SMAL", "YOUN", "MATU"),
                      LL.th = c(seq(10,2,-1), seq(1,.5, -.1)),
                      verbose = TRUE)
candpar.M <- candpar.M * M.allow
}
}
